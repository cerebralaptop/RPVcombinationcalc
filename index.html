<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>RPV Combination Calculator</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body { margin: 0; padding: 0; font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useCallback, useRef } = React;

    // Level suffixes to strip for family grouping
    const LEVEL_SUFFIXES = [
      // Metals/tiers
      ' - Platinum', ' - Gold', ' - Silver', ' - Bronze',
      ' Platinum', ' Gold', ' Silver', ' Bronze',
      // Levels
      ' - Level A', ' - Level B', ' - Level C', ' - Level D',
      ' Level A', ' Level B', ' Level C', ' Level D',
      // Percentage variants
      ' (Platinum 100% - Non Timber)', ' (Platinum 100% - Timber)',
      ' (Platinum 85% - Non Timber)', ' (Platinum 85% - Timber)',
      ' (Gold - Non Timber)', ' (Gold - Timber)',
      ' (Silver - Non Timber)', ' (Silver - Timber)',
      ' (Bronze - Non Timber)', ' (Bronze - Timber)',
      // Stars
      ' - 5 Star', ' - 4 Star', ' - 3 Star', ' - 2 Star', ' - 1 Star',
      // Generic
      ' - Full Certification', ' - Petal Certification', ' - Imperative Challenge',
      ' - Red List Free', ' - Red List Approved', ' - Declared',
    ];

    // Extract family name by stripping level suffixes
    function getFamily(initiativeName) {
      let family = initiativeName;
      for (const suffix of LEVEL_SUFFIXES) {
        if (family.endsWith(suffix)) {
          family = family.slice(0, -suffix.length);
          break;
        }
      }
      // Also try to handle patterns like "Something (Level X)"
      family = family.replace(/\s*\([^)]*(?:Platinum|Gold|Silver|Bronze|Level\s*[A-D])[^)]*\)\s*$/i, '');
      return family.trim();
    }

    // Parse raw data to build initiative -> credit -> points mapping and initiative -> applicant mapping
    function parseRawData(rows) {
      const initiativeCredits = {}; // initiative -> credit -> max points
      const initiativeApplicants = {}; // initiative -> applicant name

      // Find column indices (handle variations in column names)
      const headers = rows[0].map(h => String(h || '').toLowerCase().trim());

      // Applicant column first: "Applicant (Recognized Initiative) (Recognized Initiative)"
      let applicantCol = headers.findIndex(h => h.includes('applicant'));

      // Initiative column: "Recognized Initiative" - must NOT be the applicant column
      let initiativeCol = headers.findIndex((h, idx) =>
        idx !== applicantCol &&
        (h.includes('recognized initiative') || h.includes('recognised initiative') || h === 'recognized initiative')
      );

      let creditCol = headers.findIndex(h => h.includes('credit no') || h.includes('credit name'));
      let pointsCol = headers.findIndex(h => h.includes('awarded points'));

      // Fallback to known positions if headers not found
      if (applicantCol === -1) applicantCol = 3; // Column D
      if (initiativeCol === -1) initiativeCol = 4; // Column E (not D!)
      if (creditCol === -1) creditCol = 9; // Column J
      if (pointsCol === -1) pointsCol = 10; // Column K

      console.log('Column indices:', { applicantCol, initiativeCol, creditCol, pointsCol });
      console.log('Sample row 1:', rows[1]);

      // Process data rows
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row || row.length === 0) continue;

        const initiative = String(row[initiativeCol] || '').trim();
        const credit = String(row[creditCol] || '').trim();
        const points = parseInt(row[pointsCol]) || 0;
        const applicant = applicantCol >= 0 ? String(row[applicantCol] || '').trim() : '';

        if (!initiative || !credit) continue;

        if (!initiativeCredits[initiative]) {
          initiativeCredits[initiative] = {};
        }

        // Keep max points per credit
        if (!initiativeCredits[initiative][credit] || points > initiativeCredits[initiative][credit]) {
          initiativeCredits[initiative][credit] = points;
        }

        // Store applicant (first non-empty one found)
        if (applicant && !initiativeApplicants[initiative]) {
          initiativeApplicants[initiative] = applicant;
        }
      }

      return { initiativeCredits, initiativeApplicants };
    }

    // Calculate Final RPV for a combination of initiatives
    function calculateRPV(initiatives, initiativeCredits, allCredits) {
      const maxPerCredit = {};

      for (const credit of allCredits) {
        maxPerCredit[credit] = 0;
        for (const init of initiatives) {
          const points = initiativeCredits[init]?.[credit] || 0;
          if (points > maxPerCredit[credit]) {
            maxPerCredit[credit] = points;
          }
        }
      }

      return Object.values(maxPerCredit).reduce((sum, p) => sum + p, 0);
    }

    // Check if two initiatives can be combined (different family AND different applicant)
    function canCombine(init1, init2, familyMap, applicantMap) {
      // Must be different families
      if (familyMap[init1] === familyMap[init2]) return false;

      // Must be different applicants (if both have applicants)
      const app1 = applicantMap[init1];
      const app2 = applicantMap[init2];
      if (app1 && app2 && app1 === app2) return false;

      return true;
    }

    // Best Practice RPV threshold (highest of all categories)
    const BEST_PRACTICE_RPV = 15;

    // Generate all valid combinations
    function generateCombinations(initiatives, familyMap, applicantMap, initiativeCredits, allCredits) {
      const combinations = [];

      // Calculate RPV for each single initiative and identify Best Practice singles
      const bestPracticeSingles = new Set();
      for (const init of initiatives) {
        const rpv = calculateRPV([init], initiativeCredits, allCredits);
        combinations.push([init]);
        if (rpv >= BEST_PRACTICE_RPV) {
          bestPracticeSingles.add(init);
        }
      }

      // Filter out Best Practice singles for pairs/triples (no benefit to combining them)
      const combinableInitiatives = initiatives.filter(init => !bestPracticeSingles.has(init));

      // Pairs (cross-family AND cross-applicant, excluding Best Practice singles)
      for (let i = 0; i < combinableInitiatives.length; i++) {
        for (let j = i + 1; j < combinableInitiatives.length; j++) {
          const init1 = combinableInitiatives[i];
          const init2 = combinableInitiatives[j];
          if (canCombine(init1, init2, familyMap, applicantMap)) {
            combinations.push([init1, init2]);
          }
        }
      }

      // Triples (all three must be cross-family AND cross-applicant, excluding Best Practice singles/pairs)
      for (let i = 0; i < combinableInitiatives.length; i++) {
        for (let j = i + 1; j < combinableInitiatives.length; j++) {
          const init1 = combinableInitiatives[i];
          const init2 = combinableInitiatives[j];
          if (!canCombine(init1, init2, familyMap, applicantMap)) continue;

          // Skip if pair already achieves Best Practice (no benefit to adding a third)
          const pairRpv = calculateRPV([init1, init2], initiativeCredits, allCredits);
          if (pairRpv >= BEST_PRACTICE_RPV) continue;

          for (let k = j + 1; k < combinableInitiatives.length; k++) {
            const init3 = combinableInitiatives[k];
            // Check init3 can combine with both init1 and init2
            if (canCombine(init1, init3, familyMap, applicantMap) &&
                canCombine(init2, init3, familyMap, applicantMap)) {
              combinations.push([init1, init2, init3]);
            }
          }
        }
      }

      return combinations;
    }

    // Practice level thresholds for each Responsible category
    const PRACTICE_THRESHOLDS = {
      structure: { best: 15, good: 10 },
      envelope: { best: 15, good: 10 },
      systems: { best: 11, good: 6 },
      finishes: { best: 12, good: 7 }
    };

    // Determine practice level based on RPV and thresholds
    function getPracticeLevel(rpv, thresholds) {
      if (rpv >= thresholds.best) return 'Best Practice';
      if (rpv >= thresholds.good) return 'Good Practice';
      return 'Not met';
    }

    // Generate CSV content
    function generateCSV(results) {
      const lines = ['Initiative,Final_RPV,structure,envelope,systems,finishes'];

      for (const result of results) {
        // Combine initiatives with ' + ', filtering out empty ones
        const combinedInitiatives = result.initiatives.filter(i => i).join(' + ');
        const initCell = `"${combinedInitiatives.replace(/"/g, '""')}"`;

        const respStructure = getPracticeLevel(result.rpv, PRACTICE_THRESHOLDS.structure);
        const respEnvelope = getPracticeLevel(result.rpv, PRACTICE_THRESHOLDS.envelope);
        const respSystems = getPracticeLevel(result.rpv, PRACTICE_THRESHOLDS.systems);
        const respFinishes = getPracticeLevel(result.rpv, PRACTICE_THRESHOLDS.finishes);

        lines.push(`${initCell},${result.rpv},${respStructure},${respEnvelope},${respSystems},${respFinishes}`);
      }

      return lines.join('\n');
    }

    // Main App
    function App() {
      const [status, setStatus] = useState('idle'); // idle, parsing, calculating, done, error
      const [progress, setProgress] = useState({ current: 0, total: 0, phase: '' });
      const [stats, setStats] = useState(null);
      const [error, setError] = useState(null);
      const [csvData, setCsvData] = useState(null);
      const fileInputRef = useRef(null);

      const processFile = useCallback(async (file) => {
        setStatus('parsing');
        setError(null);
        setCsvData(null);
        setProgress({ current: 0, total: 0, phase: 'Reading Excel file...' });

        try {
          // Read file
          const data = await file.arrayBuffer();
          const workbook = XLSX.read(data, { type: 'array' });

          // Find raw data sheet
          let rawSheet = workbook.Sheets['raw data'] || workbook.Sheets['Raw Data'] || workbook.Sheets['rawdata'];
          if (!rawSheet) {
            // Try first sheet
            rawSheet = workbook.Sheets[workbook.SheetNames[0]];
          }

          if (!rawSheet) {
            throw new Error('Could not find raw data sheet');
          }

          setProgress({ current: 0, total: 0, phase: 'Parsing raw data...' });

          const rows = XLSX.utils.sheet_to_json(rawSheet, { header: 1 });
          const { initiativeCredits, initiativeApplicants } = parseRawData(rows);

          const initiatives = Object.keys(initiativeCredits).sort();
          const uniqueApplicants = new Set(Object.values(initiativeApplicants).filter(a => a));
          const allCredits = new Set();
          for (const init of initiatives) {
            for (const credit of Object.keys(initiativeCredits[init])) {
              allCredits.add(credit);
            }
          }
          const creditsArray = Array.from(allCredits).sort();

          // Build family map
          const familyMap = {};
          for (const init of initiatives) {
            familyMap[init] = getFamily(init);
          }

          const families = new Set(Object.values(familyMap));

          setProgress({ current: 0, total: 0, phase: 'Generating combinations...' });

          // Generate combinations (excluding same-family, same-applicant, and Best Practice singles)
          const combinations = generateCombinations(initiatives, familyMap, initiativeApplicants, initiativeCredits, creditsArray);

          setStats({
            initiatives: initiatives.length,
            families: families.size,
            applicants: uniqueApplicants.size,
            credits: creditsArray.length,
            singles: initiatives.length,
            pairs: combinations.filter(c => c.length === 2).length,
            triples: combinations.filter(c => c.length === 3).length,
            total: combinations.length,
          });

          setStatus('calculating');
          setProgress({ current: 0, total: combinations.length, phase: 'Calculating RPV scores...' });

          // Calculate RPV for each combination (in batches for UI responsiveness)
          const results = [];
          const batchSize = 1000;

          for (let i = 0; i < combinations.length; i += batchSize) {
            const batch = combinations.slice(i, i + batchSize);

            for (const combo of batch) {
              const rpv = calculateRPV(combo, initiativeCredits, creditsArray);
              results.push({ initiatives: combo, rpv });
            }

            setProgress({
              current: Math.min(i + batchSize, combinations.length),
              total: combinations.length,
              phase: 'Calculating RPV scores...'
            });

            // Yield to UI
            await new Promise(r => setTimeout(r, 0));
          }

          // Sort by RPV descending
          results.sort((a, b) => b.rpv - a.rpv);

          // Generate CSV
          setProgress({ current: 0, total: 0, phase: 'Generating CSV...' });
          const csv = generateCSV(results);
          setCsvData(csv);

          setStatus('done');
        } catch (err) {
          console.error('Processing error:', err);
          setError(err.message);
          setStatus('error');
        }
      }, []);

      const handleFileChange = useCallback((e) => {
        const file = e.target.files?.[0];
        if (file) {
          processFile(file);
        }
        e.target.value = '';
      }, [processFile]);

      const handleDownload = useCallback(() => {
        if (!csvData) return;

        const blob = new Blob([csvData], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'rpv_combinations.csv';
        link.click();
        URL.revokeObjectURL(url);
      }, [csvData]);

      const handleReset = useCallback(() => {
        setStatus('idle');
        setProgress({ current: 0, total: 0, phase: '' });
        setStats(null);
        setError(null);
        setCsvData(null);
      }, []);

      return (
        <div className="min-h-screen bg-gray-100">
          <header className="bg-white shadow-sm">
            <div className="max-w-4xl mx-auto px-4 py-6">
              <h1 className="text-2xl font-bold text-gray-800">RPV Combination Calculator</h1>
              <p className="text-gray-600 text-sm mt-1">
                Calculate Final RPV for all initiative combinations (single, pairs, triples)
              </p>
            </div>
          </header>

          <main className="max-w-4xl mx-auto px-4 py-8">
            {/* Upload Section */}
            {status === 'idle' && (
              <div className="bg-white rounded-xl shadow-lg p-8">
                <div className="text-center">
                  <div className="mb-6">
                    <svg className="w-16 h-16 mx-auto text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                  </div>
                  <h2 className="text-xl font-semibold text-gray-800 mb-2">Upload Raw Data Excel</h2>
                  <p className="text-gray-600 mb-6">
                    Upload an Excel file containing the "raw data" sheet with initiative credits
                  </p>
                  <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    accept=".xlsx,.xls"
                    className="hidden"
                  />
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium"
                  >
                    Select Excel File
                  </button>
                </div>

                <div className="mt-8 p-4 bg-blue-50 rounded-lg text-sm text-blue-800">
                  <strong>Expected format:</strong> Excel file with a "raw data" sheet containing columns for:
                  <ul className="mt-2 ml-4 list-disc">
                    <li>Recognized Initiative (initiative name)</li>
                    <li>Credit No. & Credit Name (credit category)</li>
                    <li>Awarded Points (points value)</li>
                    <li>Applicant Name (optional - excludes same-applicant combinations)</li>
                  </ul>
                </div>
              </div>
            )}

            {/* Processing Section */}
            {(status === 'parsing' || status === 'calculating') && (
              <div className="bg-white rounded-xl shadow-lg p-8">
                <div className="text-center">
                  <div className="animate-spin w-12 h-12 border-4 border-green-600 border-t-transparent rounded-full mx-auto mb-4"></div>
                  <h2 className="text-xl font-semibold text-gray-800 mb-2">{progress.phase}</h2>
                  {progress.total > 0 && (
                    <>
                      <div className="w-full bg-gray-200 rounded-full h-3 mb-2">
                        <div
                          className="bg-green-600 h-3 rounded-full transition-all duration-300"
                          style={{ width: `${(progress.current / progress.total) * 100}%` }}
                        ></div>
                      </div>
                      <p className="text-gray-600">
                        {progress.current.toLocaleString()} / {progress.total.toLocaleString()}
                      </p>
                    </>
                  )}
                </div>

                {stats && (
                  <div className="mt-6 grid grid-cols-2 md:grid-cols-5 gap-4">
                    <div className="bg-gray-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-gray-800">{stats.initiatives}</div>
                      <div className="text-xs text-gray-500">Initiatives</div>
                    </div>
                    <div className="bg-gray-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-gray-800">{stats.families}</div>
                      <div className="text-xs text-gray-500">Families</div>
                    </div>
                    <div className="bg-gray-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-gray-800">{stats.applicants || 0}</div>
                      <div className="text-xs text-gray-500">Applicants</div>
                    </div>
                    <div className="bg-gray-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-gray-800">{stats.credits}</div>
                      <div className="text-xs text-gray-500">Credits</div>
                    </div>
                    <div className="bg-gray-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-gray-800">{stats.total.toLocaleString()}</div>
                      <div className="text-xs text-gray-500">Combinations</div>
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Error Section */}
            {status === 'error' && (
              <div className="bg-white rounded-xl shadow-lg p-8">
                <div className="text-center">
                  <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-red-100 flex items-center justify-center">
                    <svg className="w-8 h-8 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </div>
                  <h2 className="text-xl font-semibold text-gray-800 mb-2">Processing Error</h2>
                  <p className="text-red-600 mb-6">{error}</p>
                  <button
                    onClick={handleReset}
                    className="px-6 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors font-medium"
                  >
                    Try Again
                  </button>
                </div>
              </div>
            )}

            {/* Done Section */}
            {status === 'done' && (
              <div className="bg-white rounded-xl shadow-lg p-8">
                <div className="text-center mb-6">
                  <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-green-100 flex items-center justify-center">
                    <svg className="w-8 h-8 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                    </svg>
                  </div>
                  <h2 className="text-xl font-semibold text-gray-800 mb-2">Processing Complete!</h2>
                  <p className="text-gray-600">All combinations calculated and sorted by RPV (highest first)</p>
                </div>

                {stats && (
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div className="bg-gray-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-gray-800">{stats.singles.toLocaleString()}</div>
                      <div className="text-xs text-gray-500">Singles</div>
                    </div>
                    <div className="bg-gray-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-gray-800">{stats.pairs.toLocaleString()}</div>
                      <div className="text-xs text-gray-500">Pairs</div>
                    </div>
                    <div className="bg-gray-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-gray-800">{stats.triples.toLocaleString()}</div>
                      <div className="text-xs text-gray-500">Triples</div>
                    </div>
                    <div className="bg-green-50 rounded-lg p-3 text-center">
                      <div className="text-2xl font-bold text-green-700">{stats.total.toLocaleString()}</div>
                      <div className="text-xs text-green-600">Total Rows</div>
                    </div>
                  </div>
                )}

                <div className="flex gap-4 justify-center">
                  <button
                    onClick={handleDownload}
                    className="flex items-center gap-2 px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                    </svg>
                    Download CSV
                  </button>
                  <button
                    onClick={handleReset}
                    className="px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors font-medium"
                  >
                    Process Another File
                  </button>
                </div>
              </div>
            )}
          </main>

          <footer className="max-w-4xl mx-auto px-4 py-6 text-center text-sm text-gray-500">
            RPV Combination Calculator | Generates all valid initiative combinations with Final RPV scores
          </footer>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
